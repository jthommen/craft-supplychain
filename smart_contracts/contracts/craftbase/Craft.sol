pragma solidity >=0.5.0;

library Craft {
  
  // Member function only count for topmost struct
  struct Registry { mapping(uint => Craft.Data) Data; }

  struct Loc {
    string lat;
    string lng;
  }

  // Basic object of the craft supply chain
  struct Data {
    uint upc; // Universal Product Code (UPC), generated by the Farmer, goes on the package, can be verified by the Consumer
    string name; // arg
    string description; // arg
    string producer; // arg
    address producer_id; // msg.sender
    Loc loc;
    uint prod_time; // via JS in front_end
    uint produprice;
    bool packaged; // default = false
    uint batch; // default = 0
    bool batched; // Part of big batch = true;
    State state;
    address payable owner;
  }

  // States a Craft can be in, changes as it proceeds through the supplychain
  enum State {
    productionStarted, // 0
    productionFinished, // 1
    packaged, // 2
    batched, // 3
    forSale, // 4
    sold, // 5
    shipped, // 7
    received // 8
  }

  // Define 8 events with the same 8 state values and accept 'upc' as input argument
  event ProductionStarted(uint upc);
  event ProductionFinished(uint upc);
  event Packaged(uint upc);
  event Batched(uint upc);
  event ForSale(uint upc);
  event Sold(uint upc);
  event UnBatched(uint upc);
  event Shipped(uint upc);
  event Received(uint upc);

  // Creates a unique hash out of craft informations
  function _createIdHash(
    string memory _name,
    string memory _description,
    string memory _producer,
    uint _prod_time
  ) public pure returns(uint) {
    bytes32 _bytes32Hash = keccak256(abi.encodePacked(_name, _description, _producer, _prod_time));
    return uint(_bytes32Hash);
  }

 // Starts the production process by buying raw material
  function startNewCraft(
    Registry storage self,
    string memory _name,
    string memory _description,
    string memory _producer,
    string memory _prod_lat,
    string memory _prod_lng,
    uint _prod_time
    ) public {
    uint upc = _createIdHash(_name, _description, _producer, _prod_time);
    Craft.Data memory newCraft = Craft.Data(
      upc,
      _name,
      _description,
      _producer,
      msg.sender,
      Loc(_prod_lat, _prod_lng),
      _prod_time,
      0, false, 0, false,
      Craft.State.productionStarted,
      msg.sender);
    self.Data[upc] = newCraft;
    emit ProductionStarted(upc);
  }

  // Retrieves the craft information
  function getInfo(Registry storage self, uint _upc) public view returns(
    string memory name,
    string memory description, 
    string memory producer,
    address producer_id,
    string memory prod_lat,
    string memory prod_lng,
    uint prod_time) {
    Craft.Data memory craft = self.Data[_upc];
    name = craft.name;
    description = craft.description;
    producer = craft.producer;
    producer_id = craft.producer_id;
    prod_lat = craft.loc.lat;
    prod_lng = craft.loc.lng;
    prod_time = craft.prod_time;
    return (name, description, producer, producer_id, prod_lat, prod_lng, prod_time);
  }

  // Retrieves craft owner
  function getOwner(Registry storage self, uint _upc) public view returns(address) {
    Craft.Data memory craft = self.Data[_upc];
    return craft.owner;
  }

  // Gets the craft state
  function getState(Registry storage self, uint _upc) public view returns(Craft.State) {
    Craft.Data memory craft = self.Data[_upc];
    return craft.state;
  }

  // Set states
  function stateProductionFinished(Registry storage self, uint _upc) public {
    Craft.Data storage craft = self.Data[_upc];
    craft.state = Craft.State.productionFinished;
    emit ProductionFinished(_upc);
  }

  function statePackaged(Registry storage self, uint _upc) public {
    Craft.Data storage craft = self.Data[_upc];
    craft.state = Craft.State.packaged;
    emit Packaged(_upc);
  }

  function stateForSale(Registry storage self, uint _upc) public {
    Craft.Data storage craft = self.Data[_upc];
    craft.state = Craft.State.forSale;
    emit ForSale(_upc);
  }

  function stateSold(Registry storage self, uint _upc) public {
    Craft.Data storage craft = self.Data[_upc];
    craft.state = Craft.State.sold;
    emit Sold(_upc);
  }

  function stateShipped(Registry storage self, uint _upc) public {
    Craft.Data storage craft = self.Data[_upc];
    craft.state = Craft.State.shipped;
    emit Shipped(_upc);
  }

  function stateReceived(Registry storage self, uint _upc) public {
    Craft.Data storage craft = self.Data[_upc];
    craft.state = Craft.State.received;
    emit Received(_upc);
  }

  // Batching
  function batch(Registry storage self, uint _upc, uint _batch_no) public {
    Craft.Data storage craft = self.Data[_upc];
    require(craft.producer_id == msg.sender, "Can only add crafts made by batch producer to batch.");
    craft.batch = _batch_no;
    craft.state = Craft.State.batched;
    emit Batched(_upc);
  }

  function unBatch(Registry storage self, uint _upc) public {
    Craft.Data storage craft = self.Data[_upc];
    craft.batched = false;
    craft.owner = msg.sender;
    emit UnBatched(_upc);
  }

}