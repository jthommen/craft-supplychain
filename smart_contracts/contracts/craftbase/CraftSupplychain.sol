pragma solidity >=0.5.0;

import "../roles/CraftsmanRole.sol";
import "../roles/AggregatorRole.sol";
import "../roles/RetailerRole.sol";
import "../roles/ConsumerRole.sol";

contract CraftSupplychain is CraftsmanRole, AggregatorRole, RetailerRole, ConsumerRole {

  // contract owner
  address private contractOwner;

  // Define a variable called 'upc' for Universal Product Code (UPC)
  uint  upc;

  // Define a public mapping 'items' that maps the UPC to an Item.
  mapping(uint => Craft) craftRegistry; 
  mapping(uint => Batch) batchRegistry;

  // Define a public mapping 'itemsHistory' that maps the UPC to an array of TxHash, 
  // that track its journey through the supply chain -- to be sent from DApp.
  mapping (uint => string[]) craftHistory;
  mapping (uint => string[]) batchHistory;

  // States a Craft can be in, changes as it proceeds through the supplychain
  enum State {
    // Item states
    productionStarted, // 0
    productionFinished, // 1
    packaged, // 2
    batched, // 3

    // Batch & Item States
    forSale, // 4
    sold, // 5
    pickedUp, // 6
    shipped, // 7
    received // 8
  }

  State constant defaultState = State.productionStarted;

  // Basic object of the craft supply chain
  struct Craft {
    uint upc; // Universal Product Code (UPC), generated by the Farmer, goes on the package, can be verified by the Consumer
    string name; // arg
    string description; // arg
    string producer; // arg
    address producer_id; // msg.sender
    string prod_loc; // arg
    uint prod_time; // via JS in front_end
    uint craft_price;
    bool packaged; // default = false
    uint batch; // default = 0
    bool batched; // Part of big batch = true;
    State state;
    address payable owner; // Only relevant if batched = false;
  }

  // Aggregated crafts of same kind into batches
  struct Batch {
    uint batch_no;
    string name;
    string description;
    string producer;
    address producer_id;
    string batch_loc;
    uint batch_time;
    uint[] crafts;
    uint craft_count;
    State state;
    address destination;
    uint batch_price;
    address payable owner; // Metamask-Ethereum address of the current owner as the product moves through 8 stages
    address aggregator_id; // Metamask-Ethereum address of the Aggregator
    address retailer_id; // Metamask-Ethereum address of the Retailer
  }

  // Data structures for information access
  mapping(uint => uint) batchesForSaleMap;
  mapping(address => uint[]) craftsByCraftsman;
  mapping(address => uint[]) batchesByCraftsman;
  mapping(address => uint[]) batchesByIntermediary;

  // Define 8 events with the same 8 state values and accept 'upc' as input argument
  event Harvested(uint upc);
  event Processed(uint upc);
  event Packed(uint upc);
  event ForSale(uint upc);
  event Sold(uint upc);
  event Shipped(uint upc);
  event Received(uint upc);
  event Purchased(uint upc);

  // Define a modifer that checks to see if msg.sender == owner of the contract
  modifier onlyOwner() {
    require(msg.sender == contractOwner, "Only the contract owner can use this functionality.");
    _;
  }

  // Define a modifer that verifies the Caller
  modifier verifyCaller (address _address) {
    require(msg.sender == _address, "Must be the owner to use this functionality."); 
    _;
  }

  // Define a modifier that checks if the paid amount is sufficient to cover the price
  modifier paidEnough(uint _price) { 
    require(msg.value >= _price, "Must pay enough to cover the requested price."); 
    _;
  }
  
  // Modifier that checks the craft price and refunds the remaining balance
  modifier checkCraftValue(uint _upc) {
    _;
    uint _price = craftRegistry[_upc].craft_price;
    uint amountToReturn = msg.value - _price;
    msg.sender.transfer(amountToReturn);
  }

  // Modifier that checks craft ownership
  modifier craftOwnerOf(uint _upc) {
    require(craftRegistry[_upc].owner == msg.sender, "Must be the craft owner.");
    _;
  }

  // Modifier that checks craft producer authenticity
  modifier checkCraftProducer(uint _upc) {
    require(craftRegistry[_upc].producer_id == msg.sender, "Must be the craft producer.");
    _;
  }

  // Modifier that checks batch producer authenticity
  modifier checkBatchProducer(uint _batch_no) {
    require(batchRegistry[_batch_no].producer_id == msg.sender, "Must be the batch producer.");
    _;
  }

  // Modifier that checks batch ownership
  modifier batchOwnerOf(uint _batch_no) {
    require(batchRegistry[_batch_no].owner == msg.sender, "Must be the batch owner.");
    _;
  }


  // Modifier that checks the batch price and refunds the remaining balance
  modifier checkBatchValue(uint _batch_no) {
    _;
    uint _price = batchRegistry[_batch_no].batch_price;
    uint amountToReturn = msg.value - _price;
    msg.sender.transfer(amountToReturn);
  }

  // Craft State Modifiers
  // Modifier that checks if an craft.state of a upc is productionStarted (0)
  modifier productionStarted(uint _upc) {
    require(craftRegistry[_upc].state == State.productionStarted, "Craft must have started production.");
    _;
  }

  // Modifier that checks if an craft.state of a upc is productionFinished (1)
  modifier productionFinished(uint _upc) {
    require(craftRegistry[_upc].state == State.productionFinished, "Craft must have finished production.");
    _;
  }

  // Modifier that checks if an craft.state of a upc is packaged (2)
  modifier packaged(uint _upc) {
    require(craftRegistry[_upc].state == State.packaged, "Craft must be packaged.");
    _;
  }

  // Modifier that checks if an craft.state of a upc is batched (3)
  modifier batched(uint _upc) {
    require(craftRegistry[_upc].state == State.batched, "Craft must be batched.");
    _;
  }

  // Modifier that checks if an craft.state of a upc is forSale (4)
  modifier craftForSale(uint _upc) {
    require(craftRegistry[_upc].state == State.forSale, "Craft must be put up for sale.");
    _;
  }

  // Modifier that checks if an craft.state of a upc is sold (5)
  modifier craftSold(uint _upc) {
    require(craftRegistry[_upc].state == State.sold, "Craft must be sold.");
    _;
  }

  // Modifier that checks if an craft.state of a upc is shipped (7)
  modifier craftShipped(uint _upc) {
    require(craftRegistry[_upc].state == State.shipped, "Craft must be shipped.");
    _;
  }

  // Modifier that checks if an craft.state of a upc is received (8)
  modifier craftReceived(uint _upc) {
    require(craftRegistry[_upc].state == State.received, "Craft must be received.");
    _;
  }


  // Batch State Modifiers
  // Modifier that checks if an batch.state of a batch_no is forSale (4)
  modifier batchForSale(uint _batch_no) {
    require(batchRegistry[_batch_no].state == State.forSale, "Batch must be up for sale.");
    _;
  }

  // Modifier that checks if an batch.state of a batch_no is sold (5)
  modifier batchSold(uint _batch_no) {
    require(batchRegistry[_batch_no].state == State.sold, "Batch must be sold.");
    _;
  }

  // Modifier that checks if an batch.state of a batch_no is pickedUp (6)
  modifier pickedUp(uint _batch_no) {
    require(batchRegistry[_batch_no].state == State.pickedUp, "Batch must be picked up.");
    _;
  }

  // Modifier that checks if an batch.state of a batch_no is shipped (7)
  modifier batchShipped(uint _batch_no) {
    require(batchRegistry[_batch_no].state == State.shipped, "Batch must be shipped.");
    _;
  }

  // Modifier that checks if an batch.state of a batch_no is received (8)
  modifier batchReceived(uint _batch_no) {
    require(batchRegistry[_batch_no].state == State.received, "Batch must be received.");
    _;
  }

  // In the constructor set 'owner' to the address that instantiated the contract
  // and set 'sku' to 1
  // and set 'upc' to 1
  constructor() public payable {
    contractOwner = msg.sender;
    upc = 1;
  }

  // Define a function 'kill' if required
  function kill() public {
    if (msg.sender == contractOwner) {
      selfdestruct(msg.sender);
    }
  }

  // Starts the production process by buying raw material
  function buyCraftMaterial(
    string memory _name,
    string memory _description,
    string memory _producer,
    string memory _prod_loc,
    uint _prod_time
    ) public {
    uint _upc = createIdHash(_name, _description, _producer, _prod_loc, _prod_time);
    Craft memory newCraft = Craft(
      _upc,
      _name,
      _description,
      _producer,
      msg.sender,
      _prod_loc,
      _prod_time,
      0, false, 0, false,
      State.productionStarted,
      msg.sender);
    craftRegistry[_upc] = newCraft;
    craftsByCraftsman[msg.sender].push(_upc);
  }

  // Retrieves the craft information
  function getCraftInfo(uint _upc) public view returns(
    string memory name,
    string memory description, 
    string memory producer,
    address producer_id,
    string memory prod_loc,
    uint prod_time) {
    Craft memory craft = craftRegistry[_upc];
    name = craft.name;
    description = craft.description;
    producer = craft.producer;
    producer_id = craft.producer_id;
    prod_loc = craft.prod_loc;
    prod_time = craft.prod_time;
    return (name, description, producer, producer_id, prod_loc, prod_time);
  }

  // Gets the craft state
  function getCraftState(uint _upc) public view returns(State) {
    Craft memory craft = craftRegistry[_upc];
    return craft.state;
  }

  // Creates a unique hash out of craft informations
  function createIdHash(
    string memory _name,
    string memory _description,
    string memory _producer,
    string memory _prod_loc,
    uint _prod_time
    ) public pure returns(uint) {
    bytes32 _bytes32Hash = keccak256(abi.encodePacked(_name, _description, _producer,  _prod_loc, _prod_time));
    return uint(_bytes32Hash);
  }

  
  function produceCraft(uint _upc) public checkCraftProducer(_upc) productionStarted(_upc){
    Craft storage craft = craftRegistry[_upc];
    craft.state = State.productionFinished;
  }

  function packageCraft(uint _upc) public checkCraftProducer(_upc) productionFinished(_upc){
    Craft storage craft = craftRegistry[_upc];
    craft.state = State.packaged;
  }

  function createBatch(
    string memory _name,
    string memory _description,
    string memory _producer,
    string memory _batch_loc,
    uint _batch_time
  ) public {
    uint _batch_no = createIdHash(_name, _description, _producer, _batch_loc, _batch_time);
    Batch memory newBatch = Batch(
      _batch_no,
      _name,
      _description,
      _producer,
      msg.sender,
      _batch_loc,
      _batch_time,
      new uint[](0), 0,
      State.batched,
      address(0),
      0,
      msg.sender,
      address(0),
      address(0)
    );
    batchRegistry[_batch_no] = newBatch;
    batchesByCraftsman[msg.sender].push(_batch_no);
  }

  // Retrieves the batch information
  function getBatchInfo(uint batchId) public view returns(
    string memory name,
    string memory description, 
    string memory producer,
    address producer_id,
    string memory batch_loc,
    uint batch_time) {
    Batch memory batch = batchRegistry[batchId];
    name = batch.name;
    description = batch.description;
    producer = batch.producer;
    producer_id = batch.producer_id;
    batch_loc = batch.batch_loc;
    batch_time = batch.batch_time;
    return (name, description, producer, producer_id, batch_loc, batch_time);
  }

  // Gets the batch state
  function getBatchState(uint _bach_no) public view returns(State) {
    Batch memory batch = batchRegistry[_bach_no];
    return batch.state;
  }

  // Gets the batch owner
  function getBatchOwner(uint _bach_no) public view returns(address) {
    Batch memory batch = batchRegistry[_bach_no];
    return batch.owner;
  }

  function addCraftsToBatch(uint _bach_no, uint[] memory _crafts) public checkBatchProducer(_bach_no) {
    Batch storage batch = batchRegistry[_bach_no];
    uint i;
    for(i = 0; i<_crafts.length; i++) {
      Craft memory craft = craftRegistry[_crafts[i]];
      require(craft.producer_id == msg.sender, "Can only add crafts made by batch producer to batch.");
    }
    for(i = 0; i<_crafts.length; i++) {
      batch.crafts.push(_crafts[i]);
      Craft storage craft = craftRegistry[_crafts[i]];
      craft.batch = _bach_no;
      craft.state = State.batched;
    }
    batch.craft_count += i;

  }
 
  function putBatchForSale(uint _bach_no, uint _price) public batchOwnerOf(_bach_no) {
    batchesForSaleMap[_bach_no] = _price;
    Batch storage batch = batchRegistry[_bach_no];
    batch.state = State.forSale;
  }

  function getBatchPrice(uint _bach_no) public view returns(uint price) {
    return batchesForSaleMap[_bach_no];
  }

  function buyBatch(uint _bach_no) public payable  batchForSale(_bach_no){

    // Check if batch is for sale and if enough money is paid
    uint batchCost = batchesForSaleMap[_bach_no];
    require(msg.value >= batchCost, "Not enough money available to buy the batch.");
    
    // Remove batch from sales
    batchesForSaleMap[_bach_no] = 0;

    // Transfer seller the money
    Batch storage batch = batchRegistry[_bach_no];
    address payable oldOwner = batch.owner;
    oldOwner.transfer(batchCost);

    // Update ownership
    batch.owner = msg.sender;
    batch.state = State.sold;
    batchesByIntermediary[msg.sender].push(_bach_no);

    // return over pay
    if(msg.value > batchCost) { 
      msg.sender.transfer(msg.value - batchCost);
    }
  }

  function pickUpBatch(uint _bach_no) public batchOwnerOf(_bach_no) {
    Batch storage batch = batchRegistry[_bach_no];
    batch.state = State.pickedUp;
  }

  function shipBatch(uint _bach_no, address _dest) public {
    Batch storage batch = batchRegistry[_bach_no];
    require(batchRegistry[_bach_no].owner == _dest, "Can only send batch to it's owner.");
    batch.destination = _dest;
    batch.state = State.shipped;
  }

  function receiveBatch(uint _bach_no) public {
    Batch storage batch = batchRegistry[_bach_no];
    require(batch.state == State.shipped, "Can only received shipped batches.");
    require(batch.destination == msg.sender, "Only the batch recipient can receive a batch.");
    batch.state = State.received;
  }
   /*
  function unBatch(uint _bach_no) public {

  }

  function putCraftForSale(uint _upc) public {

  }

  function purchaseCraft(uint _upc) public {

  }

  function shipCraft(uint _upc) public {

  }

  function receiveCraft(uint _upc) public {
    
  }
  */
}
